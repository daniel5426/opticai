# Adding New Exam Cards - Complete Guide

This guide documents the complete process for adding new exam cards to the optical clinic system. The system uses a registry-based architecture that automatically handles most of the integration once properly configured, now integrated with the PostgreSQL API backend.

## Overview

The exam card system consists of:
- **Database Layer**: PostgreSQL schema and API endpoints
- **Registry System**: Automatic component registration and field handling
- **Field Mappings**: For data copying between components
- **UI Components**: React components for the card interface
- **Card Renderer**: Automatic rendering and integration

## Step-by-Step Implementation

### 1. Backend Database Schema

**Add the SQLAlchemy model in `backend/models.py`:**
```python
class NewExamTypeExam(Base):
    __tablename__ = "new_exam_type_exams"
    
    id = Column(Integer, primary_key=True, index=True)
    layout_instance_id = Column(Integer, ForeignKey("exam_layout_instances.id"), nullable=False)
    # Add your specific fields here
    r_field1 = Column(Float)
    l_field1 = Column(Float)
    # ... other fields
```

**Add Pydantic schemas in `backend/schemas.py`:**
```python
class NewExamTypeExamBase(BaseModel):
    r_field1: Optional[float] = None
    l_field1: Optional[float] = None
    # ... other fields

class NewExamTypeExamCreate(NewExamTypeExamBase):
    layout_instance_id: int

class NewExamTypeExam(NewExamTypeExamBase):
    id: int
    layout_instance_id: int
    
    class Config:
        from_attributes = True
```

### 2. Backend API Endpoints

**Create `backend/EndPoints/new_exam_type.py`:**
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from database import get_db
from models import NewExamTypeExam
from schemas import NewExamTypeExamCreate, NewExamTypeExam as NewExamTypeExamSchema
from auth import get_current_user

router = APIRouter(prefix="/new-exam-type", tags=["new-exam-type"])

@router.post("/", response_model=NewExamTypeExamSchema)
def create_new_exam_type(data: NewExamTypeExamCreate, db: Session = Depends(get_db)):
    db_exam = NewExamTypeExam(**data.dict())
    db.add(db_exam)
    db.commit()
    db.refresh(db_exam)
    return db_exam

@router.get("/layout/{layout_instance_id}", response_model=NewExamTypeExamSchema)
def get_new_exam_type_by_layout(layout_instance_id: int, db: Session = Depends(get_db)):
    exam = db.query(NewExamTypeExam).filter(NewExamTypeExam.layout_instance_id == layout_instance_id).first()
    if exam is None:
        raise HTTPException(status_code=404, detail="Exam not found")
    return exam

@router.put("/{exam_id}", response_model=NewExamTypeExamSchema)
def update_new_exam_type(exam_id: int, data: NewExamTypeExamCreate, db: Session = Depends(get_db)):
    db_exam = db.query(NewExamTypeExam).filter(NewExamTypeExam.id == exam_id).first()
    if db_exam is None:
        raise HTTPException(status_code=404, detail="Exam not found")
    
    for field, value in data.dict(exclude_unset=True).items():
        setattr(db_exam, field, value)
    
    db.commit()
    db.refresh(db_exam)
    return db_exam
```

**Add to `backend/main.py`:**
```python
from EndPoints import new_exam_type
app.include_router(new_exam_type.router, prefix=settings.API_V1_STR)
```

### 3. Frontend API Client

**Add methods to `src/lib/api-client.ts`:**
```typescript
// New exam type methods
async createNewExamType(data: any) {
  return this.request('/new-exam-type', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

async getNewExamTypeByLayout(layoutInstanceId: number) {
  return this.request(`/new-exam-type/layout/${layoutInstanceId}`);
}

async updateNewExamType(examId: number, data: any) {
  return this.request(`/new-exam-type/${examId}`, {
    method: 'PUT',
    body: JSON.stringify(data),
  });
}
```

### 4. Component Registry ([src/lib/exam-component-registry.ts](mdc:src/lib/exam-component-registry.ts))

**Add to ExamComponentType union:**
```typescript
export type ExamComponentType = 'old-refraction' | 'new-exam-type' | /* ... existing types */
```

**Add import:**
```typescript
import { NewExamTypeExam } from "@/lib/db/schema-interface"
```

**Register the component:**
```typescript
registry.register<NewExamTypeExam>('new-exam-type', {
  name: 'Hebrew Name Here',
  getData: (layoutInstanceId: number) => apiClient.getNewExamTypeByLayout(layoutInstanceId),
  createData: (data: Omit<NewExamTypeExam, 'id'>) => apiClient.createNewExamType(data),
  updateData: (data: NewExamTypeExam) => apiClient.updateNewExamType(data.id!, data),
  getNumericFields: () => [/* list numeric fields */],
  getIntegerFields: () => [/* list integer fields */],
  validateField: (field, rawValue) => {
    // Field validation logic
  },
  hasData: (data) => Object.values(data).some(value => 
    value !== undefined && value !== null && value !== ''
  )
})
```

### 5. Field Mappings ([src/lib/exam-field-mappings.ts](mdc:src/lib/exam-field-mappings.ts))

**Add to type definitions:**
```typescript
export type ExamComponentType = 'old-refraction' | 'new-exam-type' | /* ... existing types */
```

**Add to defaultMaps:**
```typescript
'new-exam-type': {
  'old-refraction': { /* field mappings */ },
  'objective': { /* field mappings */ },
  // ... other mappings
}
```

**Add to getFieldNames function:**
```typescript
case 'new-exam-type':
  return [
    'r_field1', 'l_field1', // ... list all fields
  ];
```

### 6. UI Component ([src/components/exam/NewExamTypeTab.tsx](mdc:src/components/exam/NewExamTypeTab.tsx))

**Create the React component:**
```typescript
import React from "react"
import { Card } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { NewExamTypeExam } from "@/lib/db/schema-interface"

interface NewExamTypeTabProps {
  newExamTypeData: NewExamTypeExam;
  onNewExamTypeChange: (field: keyof NewExamTypeExam, value: string) => void;
  isEditing: boolean;
  hideEyeLabels?: boolean;
  needsMiddleSpacer?: boolean;
}

export const NewExamTypeTab: React.FC<NewExamTypeTabProps> = ({
  newExamTypeData,
  onNewExamTypeChange,
  isEditing,
  hideEyeLabels = false,
  needsMiddleSpacer = false
}) => {
  // Component implementation
}
```

### 7. Card Renderer Integration ([src/components/exam/ExamCardRenderer.tsx](mdc:src/components/exam/ExamCardRenderer.tsx))

The new registry-based system automatically handles most integration! You only need to:

**Add import:**
```typescript
import { NewExamTypeTab } from "@/components/exam/NewExamTypeTab"
import { NewExamTypeExam } from "@/lib/db/schema-interface"
```

**Add to CardItem type:**
```typescript
type: 'exam-details' | 'new-exam-type' | /* ... existing types */
```

**Add to appropriate component lists:**
```typescript
const componentsWithMiddleRow: CardItem['type'][] = ['old-refraction', 'new-exam-type', /* ... */];
// OR
const componentsDontHaveMiddleRow: CardItem['type'][] = ['objective', 'new-exam-type', /* ... */];
```

**Add to getColumnCount function:**
```typescript
case 'new-exam-type': return 8 // or whatever number of columns
```

**Add case in switch statement:**
```typescript
case 'new-exam-type':
  return (
    <div className="relative">
      <NewExamTypeTab
        newExamTypeData={mode === 'editor' ? emptyNewExamTypeData : detailProps!.examFormData['new-exam-type']}
        onNewExamTypeChange={mode === 'editor' ? () => {} : getFieldHandler(detailProps!.fieldHandlers, 'new-exam-type')}
        isEditing={mode === 'editor' ? false : detailProps!.isEditing}
        hideEyeLabels={hideEyeLabels}
        needsMiddleSpacer={needsMiddleSpacer}
      />
      {createToolboxForComponent('new-exam-type')}
    </div>
  )
```

## Key Benefits of This Architecture

1. **Automatic Integration**: The registry system automatically handles form data, field handlers, and validation
2. **Minimal File Changes**: Only need to update a few core files
3. **Type Safety**: Full TypeScript support throughout
4. **Automatic Layout Editor**: New components automatically appear in the layout editor
5. **Toolbox Integration**: Copy/paste functionality works automatically
6. **Field Mapping**: Data copying between components works seamlessly
7. **API Integration**: Automatic backend communication through the API client

## Common Patterns

### Field Types
- **Numeric fields**: Use `getNumericFields()` for decimal values
- **Integer fields**: Use `getIntegerFields()` for whole numbers  
- **String fields**: Default handling for text values

### Component Layout
- **Components with middle row**: Add to `componentsWithMiddleRow` for combined fields
- **Components without middle row**: Add to `componentsDontHaveMiddleRow` for simpler layouts

### Special Features
- **No V+H button**: Don't include vector+horizontal calculator
- **Separate prism fields**: Use `PR.H`, `BASE.H`, `PR.V`, `BASE.V` instead of combined
- **Combined fields**: Place in middle row between R and L columns

## Testing Checklist

- [ ] Backend API endpoints work correctly
- [ ] Database schema creates correctly
- [ ] CRUD operations work via API
- [ ] Component appears in layout editor
- [ ] Form data saves and loads
- [ ] Field validation works
- [ ] Toolbox copy/paste functions
- [ ] Component renders in both editor and detail modes
- [ ] RTL layout displays correctly
- [ ] API authentication works properly

## Notes

- Always follow Hebrew RTL layout patterns
- Use `style={{scrollbarWidth: 'none'}}` to hide scrollbars
- Components automatically get registered in the layout editor
- The registry system handles most of the complexity automatically
- Field mappings enable data copying between compatible components
- API client handles all backend communication automatically
