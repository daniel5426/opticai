---
description: 
globs: 
alwaysApply: true
---
# Electron-Vite-React Project Overview

This project is an Electron desktop application built with Vite, React, and TypeScript. The project includes SQLite database integration for data persistence and uses shadcn/ui for UI components.An all-in-one management system for optical clinics and stores, handling patient records, medical and optical exams, orders, billing, and inventory.
Streamlines clinic operations from eye exams to lens and frame orders, ensuring efficient and accurate patient care.

## UI Components

The application uses [shadcn/ui](mdc:https:/ui.shadcn.com) for UI components, which provides:
- Beautifully designed components
- Accessibility-focused design
- Tailwind CSS for styling
- Customizable and reusable components

ALWAYS FOLLOW THOSE GUIDELINE FOR UI:
- Its an app in hebrew, so ui need to be rtl
- each new page created should be added a button in the appsidebar to go to it
- ALWAYS in every page or component use: style={{scrollbarWidth: 'none'}}
  to hide the vizible scrollbar without removing the functionality of scrolling
- ALWAYS if you want to create a modal use the [src/components/ui/cusom-modal.tsx](mdc:src/components/ui/cusom-modal.tsx) component
- When creating classic buttons try to use icons instead of label text, use text only if its an unusual button
- try to not have dupclicated codes, create components when a part of code is used multiple time.

## Routing System

The application uses [TanStack Router](mdc:https:/tanstack.com/router) for client-side routing:
- Memory-based router optimized for Electron applications
- Declarative route definitions in `src/routes/routes.tsx`
- Root layout with outlet pattern in `src/routes/__root.tsx` 
- Navigation through `Link` components:
  ```tsx
  <Link to="/path">Link Text</Link>
  ```
- Clean, type-safe routing with automatic type generation
- Route parameters and nested routes support

## Database System

The application uses SQLite with better-sqlite3 for local data persistence. A major refactoring has simplified database interactions by implementing a generic IPC channel (`db-operation`).

### Key Database Features
- **Generic IPC Handler**: A single `'db-operation'` channel in [src/main.ts](mdc:src/main.ts) dynamically calls methods on the `DatabaseService`. This eliminates the need to register individual IPC handlers for each database operation.
- **Dynamic Connection Manager**: The renderer process uses a `connectionManager` ([src/lib/db/connection-manager.ts](mdc:src/lib/db/connection-manager.ts)), which is a Proxy that forwards calls to the main process via the generic IPC channel, providing a clean and type-safe API.
- **Type Safety**: End-to-end type safety is maintained. `DBServiceType` is generated from the `DatabaseService` class, ensuring that calls from the renderer process via `connectionManager` are fully typed.
- **WAL Mode**: Write-Ahead Logging for better performance.
- **Foreign Keys**: Enabled for referential integrity.
- **Auto-initialization**: Tables created on first run with seed data.
- **TypeScript Integration**: Fully typed interfaces for all entities.

### Making Database Schema Changes

**⚠️ IMPORTANT**: When adding new database entities or modifying schemas, the process is now much simpler:

#### 1. Schema Definition (`src/lib/db/schema.ts`)
This step remains the same. Define the TypeScript interface and add the `CREATE TABLE` statement in the `createTables` function.
```typescript
// Add/update interface
export interface TableName {
  id?: number;
  new_field?: string;
  // ... existing fields
}

// Add table creation in createTables function
CREATE TABLE IF NOT EXISTS table_name (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  new_field TEXT,
  // ... existing fields
);
```

#### 2. Database Service Methods (`src/lib/db/index.ts`)
This step also remains the same. Add the corresponding CRUD methods for the new entity to the `DatabaseService` class in [src/lib/db/index.ts](mdc:src/lib/db/index.ts). These methods are automatically exposed to the renderer process.
```typescript
// Add CRUD operations for new entity
createTableName(data: Omit<TableName, 'id'>): TableName | null {
  // Implementation
}

getTableNameById(id: number): TableName | null {
  // Implementation
}
// ... other methods
```

#### 3. API Layer (`src/lib/db/table-name-db.ts`)
Create a new `src/lib/db/table-name-db.ts` file (or add to an existing one). The functions in this file should simply call the corresponding methods on the `connectionManager`.
```typescript
import { connectionManager } from './connection-manager';
import { TableName } from './schema';

export function createTableName(data: Omit<TableName, 'id'>) {
  return connectionManager.createTableName(data);
}

export function getTableNameById(id: number) {
  return connectionManager.getTableNameById(id);
}
// ... other wrapper functions
```
With this new architecture, you no longer need to manually edit [src/main.ts](mdc:src/main.ts), [src/preload.ts](mdc:src/preload.ts), or [src/types/electron.d.ts](mdc:src/types/electron.d.ts) when adding new database operations.

### Database Reset (Development)
- **Delete** the existing database file from user data directory
- **Restart** the application to recreate with new schema
- Database path: `%APPDATA%/electron-shadcn Template/database.sqlite`

### Common Issues & Solutions

**"DB method '...' not found" Errors:**
- Ensure the method name in your renderer call (e.g., `connectionManager.myMethod()`) exactly matches the method name in the `DatabaseService` class in `src/lib/db/index.ts`.
- Make sure you have restarted the application after making changes to [src/lib/db/index.ts](mdc:src/lib/db/index.ts).

**"Column doesn't exist" Errors:**
- Delete old database file to recreate schema
- Ensure new fields are included in both interface and CREATE TABLE
- Update all INSERT/UPDATE statements with new fields


### Best Practices
- Always use TypeScript interfaces for type safety
- Keep schema definitions and database service in sync
- Use the `connectionManager` via wrapper functions in `*-db.ts` files for all database calls from the renderer process.
- Test database operations after schema changes
- Use proper error handling in database operations
- Delete old database during development when schema changes
